<html>

<head>
<title>ICG WebGL &mdash; HW1</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<!-- <meta http-equiv="content-type" content="text/html; charset=ISO-8859-1"> -->
<link rel="stylesheet" href="overlay.css">
<link rel="stylesheet" href="UI.css">
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css" integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">

<script type="text/javascript" src="glMatrix-0.9.5.min.js"></script>
<script type="text/javascript" src="webgl-utils.js"></script>
<script type="text/javascript" src="draw.js"></script>

<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
<script id="fragmentShader_color_p" type="fragment">
	precision mediump float;
	varying vec4 fragcolor;
	varying vec3 vNormal;
	varying vec3 position;
	uniform vec3 uLightPosition[3];
	uniform vec3 uLightColor[3];

	void main(void) {
		float uShininess = 30.0;
		vec4 uLightAmbient = vec4(0.03,0.03,0.03,1.0);
		vec4 uMaterialSpecular = vec4(5.0,5.0,5.0,1.0);
		vec4 uMaterialDiffuse = vec4(0.5,0.8,0.1,1.0);
		vec4 uMaterialAmbient = vec4(1.0,1.0,1.0,1.0);

		gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
		for (int i = 0; i < 3; i++) {
			vec3 N = normalize(vNormal);
			vec3 L = normalize(uLightPosition[i] - position);

			// Lambert's cosine law
			float lambertian = max(dot(N, L), 0.0);

			//Ambient Term
			vec4 Ia = uMaterialAmbient * uLightAmbient;

			//Diffuse Term
			vec4 Id = vec4(fragcolor.rgb * lambertian * uLightColor[i], fragcolor.a);

			//Specular Term
			vec3 R = reflect(-L, N);      // Reflected light vector
			vec3 V = normalize(-position); // Vector to viewer
			float specular = pow( max(dot(R, V), 0.0), uShininess);
			
			vec4 Is = uMaterialSpecular * specular * vec4(uLightColor[i],1.0);

			gl_FragColor += Ia + Id + Is;
		}
	}
</script>

<script id="vertexShader_color_p" type="vertex">
	attribute vec3 aVertexPosition;
	attribute vec3 aFrontColor;
	attribute vec3 aVertexNormal;

	uniform mat4 uMVMatrix;
	uniform mat4 uPMatrix;

	varying vec4 fragcolor;
	varying vec3 vNormal;
	varying vec3 position;
	uniform sampler2D uSampler;

	void main(void) {
		gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
		fragcolor = vec4(aFrontColor.rgb, 1.0);

		vNormal = mat3(uMVMatrix) * aVertexNormal;

		vec4 vertPos4 = uMVMatrix * vec4(aVertexPosition, 1.0);
		position = vec3(vertPos4) / vertPos4.w;
	}
</script>

<script id="fragmentShader_color_f" type="fragment">
	#extension GL_EXT_shader_texture_lod : enable
	#extension GL_OES_standard_derivatives : enable
	precision mediump float;
	varying vec4 fragcolor;
	varying vec3 fragVertexEc;
	uniform vec3 uLightPosition[3];
	uniform vec3 uLightColor[3];
	void main(void) {
		vec3 X = dFdx(fragVertexEc);
		vec3 Y = dFdy(fragVertexEc);
		vec3 normal = normalize(cross(X,Y));

		float lightRatio = dot(normalize(uLightPosition[0] - fragVertexEc), normal);
		gl_FragColor = fragcolor * vec4(lightRatio * uLightColor[0], 1.0);
	}
</script>

<script id="vertexShader_color_f" type="vertex">
	attribute vec3 aVertexPosition;
	attribute vec3 aFrontColor;

	uniform mat4 uMVMatrix;
	uniform mat4 uPMatrix;

	varying vec4 fragcolor;
	varying vec3 fragVertexEc;
	uniform sampler2D uSampler;

	void main(void) {
		gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
		fragcolor = vec4(aFrontColor.rgb, 1.0);
		fragVertexEc = (mat3(uMVMatrix) * aVertexPosition);
	}
</script>

<script id="fragmentShader_color_g" type="fragment">
	precision mediump float;
	varying vec4 fragcolor;
	void main(void) {
		gl_FragColor = fragcolor;
	}
</script>

<script id="vertexShader_color_g" type="vertex">
	attribute vec3 aVertexPosition;
	attribute vec3 aFrontColor;
	attribute vec3 aVertexNormal;

	uniform mat4 uMVMatrix;
	uniform mat4 uPMatrix;
	uniform vec3 uLightPosition[3];
	uniform vec3 uLightColor[3];

	varying vec4 fragcolor;
	uniform sampler2D uSampler;

	void main(void) {
		gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
		vec4 vertPos4 = uMVMatrix * vec4(aVertexPosition, 1.0);
  	vec3 vertPos = vec3(vertPos4) / vertPos4.w;

		float uShininess = 20.0;
		vec4 uLightAmbient = vec4(0.03,0.03,0.03,1.0);
		vec4 uMaterialSpecular = vec4(1.0,1.0,1.0,1.0);
		vec4 uMaterialDiffuse = vec4(0.5,0.8,0.1,1.0);
		vec4 uMaterialAmbient = vec4(1.0,1.0,1.0,1.0);

		fragcolor = vec4(0.0, 0.0, 0.0, 0.0);
		for (int i = 0; i < 3; i++) {
			vec3 L = normalize(uLightPosition[i] - vertPos);
			vec3 N = normalize(mat3(uMVMatrix) * aVertexNormal);
			// Lambert's cosine law
			float lambertian = max( dot(N, L), 0.0);

			//Ambient Term
			vec4 Ia = uMaterialAmbient * uLightAmbient;

			//Diffuse Term
			vec4 Id = vec4(aFrontColor.rgb * lambertian * uLightColor[i], 1.0);

			//Specular Term
			vec3 R = reflect(-L, N);      // Reflected light vector
			vec3 V = normalize(-vertPos); // Vector to viewer
			float specular = pow( max(dot(R, V), 0.0), uShininess);
			vec4 Is = uMaterialSpecular * specular * vec4(uLightColor[i],1.0);

			fragcolor += Ia + Id + Is;
		}
	}
</script>

<script type="text/javascript">

	var gl;

	function initGL(canvas) {
		try {
			gl = canvas.getContext("experimental-webgl");
			gl.getExtension('OES_standard_derivatives');
			gl.getExtension('EXT_shader_texture_lod');
			gl.viewportWidth = canvas.width;
			gl.viewportHeight = canvas.height;
		} catch (e) {
		}
		if (!gl) {
			alert("Could not initialise WebGL, sorry :-(");
		}
	}


	function getShader(gl, id) {
		var shaderScript = document.getElementById(id);
		if (!shaderScript) {
			return null;
		}

		var str = "";
		var k = shaderScript.firstChild;
		while (k) {
			if (k.nodeType == 3) {
				str += k.textContent;
			}
			k = k.nextSibling;
		}

		var shader;
		if (shaderScript.type == "fragment") {
			shader = gl.createShader(gl.FRAGMENT_SHADER);
		} else if (shaderScript.type == "vertex") {
			shader = gl.createShader(gl.VERTEX_SHADER);
		} else {
			return null;
		}

		gl.shaderSource(shader, str);
		gl.compileShader(shader);

		if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
			alert(gl.getShaderInfoLog(shader));
			return null;
		}

		return shader;
	}


	var shaderProgram;
	var colorProgram  = [];

	function initShaders(type, flag) {
		if (flag == "_texture") {
			type = document.getElementById("shadertype").value;
		}

		var fragmentShader = getShader(gl, "fragmentShader"+flag+type);
		var vertexShader = getShader(gl, "vertexShader"+flag+type);

		var program = gl.createProgram();
		gl.attachShader(program, vertexShader);
		gl.attachShader(program, fragmentShader);
		gl.linkProgram(program);

		if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
			alert("Could not initialise shaders");
		}

		gl.useProgram(program);

		program.vertexPositionAttribute = gl.getAttribLocation(program, "aVertexPosition");
		gl.enableVertexAttribArray(program.vertexPositionAttribute);

		if (type != "_f") {
			program.aVertexNormal = gl.getAttribLocation(program, "aVertexNormal");
			gl.enableVertexAttribArray(program.aVertexNormal);
		}

		program.pMatrixUniform = gl.getUniformLocation(program, "uPMatrix");
		program.mvMatrixUniform = gl.getUniformLocation(program, "uMVMatrix");
		program.samplerUniform = gl.getUniformLocation(program, "uSampler");
		program.uLightPosition = [];
		program.uLightColor = [];
		for (var i = 0; i < 3; i++) {
			var tmp = gl.getUniformLocation(program, "uLightPosition["+i+"]");
			program.uLightPosition.push(tmp);
			var tnp = gl.getUniformLocation(program, "uLightColor["+i+"]");
			program.uLightColor.push(tnp);
		}

		if (flag == "_color") {
			program.vertexFrontColorAttribute = gl.getAttribLocation(program, "aFrontColor");
			gl.enableVertexAttribArray(program.vertexFrontColorAttribute); 
			colorProgram.push(program);
		} else { //texture
			program.textureCoordAttribute = gl.getAttribLocation(program, "aTextureCoord");
			gl.enableVertexAttribArray(program.textureCoordAttribute);
			shaderProgram = program;
		}
	}


	function handleLoadedTexture(texture) {
		gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
		gl.bindTexture(gl.TEXTURE_2D, texture);
		gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture.image);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);
		gl.generateMipmap(gl.TEXTURE_2D);

		gl.bindTexture(gl.TEXTURE_2D, null);
	}

	var galvanizedTexture;

	function initTextures() {
		galvanizedTexture = gl.createTexture();
		galvanizedTexture.image = new Image();
		galvanizedTexture.image.onload = function () {
			handleLoadedTexture(galvanizedTexture)
		}
		galvanizedTexture.image.src = "galvanizedTexture.jpg";
	}


	var mvMatrix = mat4.create();
	var pMatrix = mat4.create();
	var nMatrix = mat4.create();
	var lightPosition = [[0,100,-20], [50,0,-40],[-100,-100,-20]];
	var lightColor = [[1.5,1.5,1.5],[1.5,1.5,1.5],[1.5,1.5,1.5]];

	function setMatrixUniforms() {
		gl.uniformMatrix4fv(shaderProgram.pMatrixUniform, false, pMatrix);
		gl.uniformMatrix4fv(shaderProgram.mvMatrixUniform, false, mvMatrix);
		gl.uniformMatrix4fv(shaderProgram.uNMatrix, false, nMatrix);
	}
	function setLighting() {
		for (var i = 0; i < 3; i++) {
			gl.uniform3fv(shaderProgram.uLightPosition[i], lightPosition[i]);
			gl.uniform3fv(shaderProgram.uLightColor[i], lightColor[i]);
		}
	}
	function setMatrixUniforms_color(idx) {
		gl.uniformMatrix4fv(colorProgram[idx].pMatrixUniform, false, pMatrix);
		gl.uniformMatrix4fv(colorProgram[idx].mvMatrixUniform, false, mvMatrix);
		gl.uniformMatrix4fv(colorProgram[idx].uNMatrix, false, nMatrix);
	}
	function setLighting_color(idx) {
		for (var i = 0; i < 3; i++) {
			gl.uniform3fv(colorProgram[idx].uLightPosition[i], lightPosition[i]);
			gl.uniform3fv(colorProgram[idx].uLightColor[i], lightColor[i]);
		}
	}

	function degToRad(degrees) {
		return degrees * Math.PI / 180;
	}


	var teapotVertexPositionBuffer;
	var teapotVertexNormalBuffer;
	var teapotVertexTextureCoordBuffer;
	var teapotVertexIndexBuffer;

	function handleLoadedTeapot(teapotData) {
		teapotVertexNormalBuffer = gl.createBuffer();
		gl.bindBuffer(gl.ARRAY_BUFFER, teapotVertexNormalBuffer);
		gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(teapotData.vertexNormals), gl.STATIC_DRAW);
		teapotVertexNormalBuffer.itemSize = 3;
		teapotVertexNormalBuffer.numItems = teapotData.vertexNormals.length / 3;

		teapotVertexTextureCoordBuffer = gl.createBuffer();
		gl.bindBuffer(gl.ARRAY_BUFFER, teapotVertexTextureCoordBuffer);
		gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(teapotData.vertexTextureCoords), gl.STATIC_DRAW);
		teapotVertexTextureCoordBuffer.itemSize = 2;
		teapotVertexTextureCoordBuffer.numItems = teapotData.vertexTextureCoords.length / 2;

		teapotVertexPositionBuffer = gl.createBuffer();
		gl.bindBuffer(gl.ARRAY_BUFFER, teapotVertexPositionBuffer);
		gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(teapotData.vertexPositions), gl.STATIC_DRAW);
		teapotVertexPositionBuffer.itemSize = 3;
		teapotVertexPositionBuffer.numItems = teapotData.vertexPositions.length / 3;

		teapotVertexIndexBuffer = gl.createBuffer();
		gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, teapotVertexIndexBuffer);
		gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(teapotData.indices), gl.STATIC_DRAW);
		teapotVertexIndexBuffer.itemSize = 1;
		teapotVertexIndexBuffer.numItems = teapotData.indices.length;
	}

	var colorVertexPositionBuffer_list = [];
  var colorVertexNormalBuffer_list = [];
  var colorVertexFrontColorBuffer_list = [];
  var colorVertexBackColorBuffer_list = [];

  function handleLoadedTeapot_color(colorData) {
    var colorVertexNormalBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, colorVertexNormalBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colorData.vertexNormals), gl.STATIC_DRAW);
    colorVertexNormalBuffer.itemSize = 3;
    colorVertexNormalBuffer.numItems = colorData.vertexNormals.length / 3;
    colorVertexNormalBuffer_list.push(colorVertexNormalBuffer);

    var colorVertexFrontColorBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, colorVertexFrontColorBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colorData.vertexFrontcolors), gl.STATIC_DRAW);
    colorVertexFrontColorBuffer.itemSize = 3;
    colorVertexFrontColorBuffer.numItems = colorData.vertexFrontcolors.length / 3;
    colorVertexFrontColorBuffer_list.push(colorVertexFrontColorBuffer);

    var colorVertexBackColorBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, colorVertexBackColorBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colorData.vertexBackcolors), gl.STATIC_DRAW);
    colorVertexBackColorBuffer.itemSize = 3;
    colorVertexBackColorBuffer.numItems = colorData.vertexBackcolors.length / 3;
    colorVertexBackColorBuffer_list.push(colorVertexBackColorBuffer);

    var colorVertexPositionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, colorVertexPositionBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colorData.vertexPositions), gl.STATIC_DRAW);
    colorVertexPositionBuffer.itemSize = 3;
    colorVertexPositionBuffer.numItems = colorData.vertexPositions.length / 3;
    colorVertexPositionBuffer_list.push(colorVertexPositionBuffer);
  }


	function loadTeapot_color(filename) {
    var request = new XMLHttpRequest();
    request.open("GET", filename);
    request.onreadystatechange = function () {
      if (request.readyState == 4) {
        handleLoadedTeapot_color(JSON.parse(request.responseText));
      }
    }
    request.send();
	}


	var teapotAngle = 180;
	var initposition = [15, 0, -35];
	var position = [15, 0, -35];
	var scale = 0.5;
	var shear = [1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1];
	var button = false;

	function drawScene() {
		gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
		gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

		if (teapotVertexPositionBuffer == null || teapotVertexNormalBuffer == null || teapotVertexTextureCoordBuffer == null || teapotVertexIndexBuffer == null) {
			return;
		}
		gl.useProgram(shaderProgram);
		mat4.perspective(45, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0, pMatrix);

		mat4.identity(mvMatrix);

		mat4.translate(mvMatrix, position);
		mat4.scale(mvMatrix, [scale,scale,scale]);

		mat4.multiply(mvMatrix, shear);
		if (button) {
			mat4.rotate(mvMatrix, degToRad(teapotAngle), [0, 1, 0]);
		}
		

		gl.activeTexture(gl.TEXTURE0);
		gl.bindTexture(gl.TEXTURE_2D, galvanizedTexture);
		
		gl.uniform1i(shaderProgram.samplerUniform, 0);

		gl.bindBuffer(gl.ARRAY_BUFFER, teapotVertexPositionBuffer);
		gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, 3, gl.FLOAT, false, 0, 0);

		var type = document.getElementById("shadertype").value;
		if (type != "_f") {
			gl.bindBuffer(gl.ARRAY_BUFFER, teapotVertexNormalBuffer);
			gl.vertexAttribPointer(shaderProgram.aVertexNormal , 3,gl.FLOAT, false, 0,0);
		}
		gl.bindBuffer(gl.ARRAY_BUFFER, teapotVertexTextureCoordBuffer);
		gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, 2, gl.FLOAT, false, 0, 0);
		gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, teapotVertexIndexBuffer);
		setMatrixUniforms();
		setLighting();
		gl.drawElements(gl.TRIANGLES, teapotVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0); //2976
	}
	var color_position = [[0, 0, -15], [0, -1, -15]];
	var button_color = [false,false];
	function drawScene_color(i) {
    // gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
    // gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

    if (colorVertexPositionBuffer_list[i] == null || colorVertexNormalBuffer_list[i] == null || colorVertexFrontColorBuffer_list[i] == null || colorVertexBackColorBuffer_list[i] == null) {
      return;
    }
    gl.useProgram(colorProgram[i]);
    // mat4.perspective(45, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0, pMatrix);

    mat4.identity(mvMatrix);

    mat4.translate(mvMatrix, color_position[i]);
    mat4.scale(mvMatrix, [4,4,4]);

    if (button_color[i]) {
    	mat4.rotate(mvMatrix, degToRad(teapotAngle), [0, 1, 0]);
    }
    mat4.rotate(mvMatrix, degToRad(-90), [1, 0, 0]);
    if (i == 1) {
    	mat4.rotate(mvMatrix, degToRad(65), [0, 0, 1]);
    	mat4.scale(mvMatrix, [2,2,2]);
    }

    
    gl.uniform1i(colorProgram[i].samplerUniform, 0);
    gl.bindBuffer(gl.ARRAY_BUFFER, colorVertexPositionBuffer_list[i]);
    gl.vertexAttribPointer(colorProgram[i].vertexPositionAttribute, colorVertexPositionBuffer_list[i].itemSize, gl.FLOAT, false, 0, 0);
    gl.bindBuffer(gl.ARRAY_BUFFER, colorVertexNormalBuffer_list[i]);
		gl.vertexAttribPointer(colorProgram[i].aVertexNormal , 3,gl.FLOAT, false, 0,0);
    gl.bindBuffer(gl.ARRAY_BUFFER, colorVertexFrontColorBuffer_list[i]);
    gl.vertexAttribPointer(colorProgram[i].vertexFrontColorAttribute, colorVertexFrontColorBuffer_list[i].itemSize, gl.FLOAT, false, 0, 0);

    setMatrixUniforms_color(i);
    setLighting_color(i);
    gl.drawArrays(gl.TRIANGLES, 0, colorVertexPositionBuffer_list[i].numItems);
   }


	var lastTime = 0;
	// var state = [0.]
	function animate() {
		var timeNow = new Date().getTime();
		if (lastTime != 0) {
			var elapsed = timeNow - lastTime;
			teapotAngle += 0.03 * elapsed;
		}
		lastTime = timeNow;
	}


	function tick() {
		requestAnimFrame(tick);
		drawScene();
		drawScene_color(1);
		drawScene_color(0);
		animate();
	}


	function webGLStart() {
		console.log("webgl start");
		var canvas = document.getElementById("ICG-canvas");
		initGL(canvas);
		initShaders("_p", "_color");
		loadTeapot_color("Kangaroo.json");

		gl.clearColor(0.1, 0.1, 0.2, 1.0);
		gl.enable(gl.DEPTH_TEST);

		tick();
	}

	function change() {
		var x = parseInt(document.getElementById("x").value);
		var y = parseInt(document.getElementById("y").value);
		var z = parseInt(document.getElementById("z").value);
		var s = parseFloat(document.getElementById("scale").value);
		var sh_x = parseFloat(document.getElementById("shear_x").value);
		var sh_y = parseFloat(document.getElementById("shear_y").value);
		var sh_z = parseFloat(document.getElementById("shear_z").value);
		position[0] = x + initposition[0];
		position[1] = y + initposition[1];
		position[2] = z + initposition[2];
		scale = s;
		shear[1] = sh_x;
		shear[6] = sh_y;
		shear[9] = sh_z;
	}

	function light(i) {
		var light = parseInt(document.getElementById("light"+i).value);
		lightColor[i] = [light,light,light];
	}


	function rotatebutton() {
		var element = document.getElementById("rotate");
		if (button) {
			button = false;
			element.classList.remove("active");
		} else {
			button = true;
			element.classList.add("active");
		}
	}
	function rotatebutton_color(i) {
		var element = document.getElementById("rotate_color"+i);
		if (button_color[i]) {
			button_color[i] = false;
			element.classList.remove("active");
		} else {
			button_color[i] = true;
			element.classList.add("active");
		}
	}

</script>


</head>


<body onload="setContext();webGLStart();">
<div class="container-fluid py-3 px-4" style="background-color: #111131">
	<div class="row">
		<canvas id="ICG-canvas" style="border: none;" width="1420" height="600"></canvas>
	</div>
	<br/>
	<div class="row">
		<div class="col-1">
			<button onclick="clearCanvas()" type="button" class="form-control btn btn-outline-light">清空</button>
		</div>
		<div class="col-3 text-white row">
			<label class="text-center col-3 my-3">Light</label>
			<div class="col-8">
				<input class="row text-white" onchange="light(0)" id="light0" type="range" min="0.0" max="2.0" step="0.1" value="1" />
				<input class="row text-white" onchange="light(1)" id="light1" type="range" min="0.0" max="2.0" step="0.1" value="1" />
				<input class="row text-white" onchange="light(2)" id="light2" type="range" min="0.0" max="2.0" step="0.1" value="1" />
			</div>
		</div>
		<div class="col-2">
			<div class="form-inline form-group input-group-sm row">
				<button type="button" class="form-control col-4 offset-6 btn btn-outline-light" id="rotate" onclick="rotatebutton()">rotate</button>
				<button type="button" class="form-control col-4 offset-6 btn btn-outline-light" id="rotate_color0" onclick="rotatebutton_color(0)">rotate</button>
				<button type="button" class="form-control col-4 offset-6 btn btn-outline-light" id="rotate_color1" onclick="rotatebutton_color(1)">rotate</button>
			</div>
		</div>
		<div class="col-5">
			<div class="form-inline form-group input-group-sm row" style="color:white">
				<label class="col-3">Teapot</label>
				<select class="form-control col offset-1 bg-dark text-white" onchange="initShaders('_f', '_texture')" id="shadertype">
					<option value="_f">Flat Shading</option>
					<option value="_g">Gouraud Shading</option>
					<option value="_p">Phong Shading</option>
				</select>
			</div>
			<div class="form-inline form-group input-group-sm row text-white">
				<label class="col-3">position:</label>
				<label class="col-1">x</label>
				<label class="col-1">15</label>
				<input class="form-control col-1 bg-dark text-white" onchange="change()" id="x" type="number" min="-10" max="10" value="0" />
				<label class="col-1">y</label>
				<label class="col-1">0</label>
				<input class="form-control col-1 bg-dark text-white" onchange="change()" id="y" type="number" min="-10" max="10" value="0" />
				<label class="col-1">z</label>
				<label class="col-1">-35</label>
				<input class="form-control col-1 bg-dark text-white" onchange="change()" id="z" type="number" min="-10" max="10" value="0" />
			</div>
			<div class="form-inline form-group input-group-sm row text-white">
				<label class="col-3">scale:</label>
				<input class="form-control col-8 offset-1 bg-dark text-white" onchange="change()" id="scale" type="number" min="0.3" max="1.5" step="0.1" value="0.5" />
			</div>
			<div class="form-inline form-group input-group-sm row text-white">
				<label class="col-3">shear:</label>
				<label class="col-1">x</label>
				<input class="form-control col-2 bg-dark text-white" onchange="change()" id="shear_x" type="number" min="-0.8" max="0.8" step="0.1" value="0" />
				<label class="col-1">y</label>
				<input class="form-control col-2 bg-dark text-white" onchange="change()" id="shear_y" type="number" min="-0.8" max="0.8" step="0.1" value="0" />
				<label class="col-1">z</label>
				<input class="form-control col-2 bg-dark text-white" onchange="change()" id="shear_z" type="number" min="-0.8" max="0.8" step="0.1" value="0" />
			</div>
		</div>
	</div>
</div>
<canvas id="overlay" width=1420;  height=600; 
        onmousedown="mousedownHandler(event)" 
        onmousemove="mousemoveHandler(event)"
        onmouseup="mouseupHandler(event)"
        style="cursor:pointer; background-color: transparent"       
         >
</canvas>

</body>

</html>
